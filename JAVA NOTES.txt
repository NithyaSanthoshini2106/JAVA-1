What is Java?
Java is a high-level, object-oriented, and class-based programming language developed by Sun Microsystems (now owned by Oracle Corporation). 
It was first released in 1995 and has since become one of the most widely used programming languages in the world.

Common Java Applications:

Web Applications (e.g., using Spring or JSP/Servlets)

Mobile Applications (mainly Android apps)

Desktop Applications

Enterprise Software

Scientific Applications

Games and Embedded Systems

Key Features of Java:
| Feature                  | Description                                                                    |
| ------------------------ | ------------------------------------------------------------------------------ |
| **Object-Oriented**      | Everything is treated as an object (except primitives).                        |
| **Platform Independent** | Java programs run on the Java Virtual Machine (JVM), not directly on hardware. |
| **Simple and Easy**      | Syntax is easy to learn and similar to C++.                                    |
| **Secure**               | Offers built-in security features (no pointer manipulation).                   |
| **Robust**               | Strong memory management and error handling.                                   |
| **Multithreaded**        | Supports multi-tasking via threads.                                            |
| **Portable**             | Bytecode can run on any machine with a JVM.                                    |
| **Distributed**          | Helps create distributed applications (e.g., using RMI, EJB).                  |


code:
----
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}


1.JVM (Java Virtual Machine):
A virtual machine that runs Java bytecode.

2.JRE (Java Runtime Environment):
A package that provides everything needed to run Java programs.

Includes:

JVM
Core libraries
Supporting files

3.JDK (Java Development Kit):
A complete package for Java development.

Includes:

JRE
JVM
Development tools (like javac, java, javadoc, javap, etc.)

4.JIT (Just-In-Time Compiler):
Part of the JVM.



| Term    | Full Form                | Purpose             | Contains        | Needed For             |
| ------- | ------------------------ | ------------------- | --------------- | ---------------------- |
| **JVM** | Java Virtual Machine     | Executes bytecode   | -               | Running Java           |
| **JRE** | Java Runtime Environment | Runs Java apps      | JVM + Libraries | Running Java           |
| **JDK** | Java Development Kit     | Develops Java apps  | JRE + Dev tools | Writing + Running Java |
| **JIT** | Just-In-Time Compiler    | Speeds up execution | Part of JVM     | Performance Boost      |


=========================================================================
Class :
In Java, a class is a blueprint or template used to create objects.

How to Make a Class Immutable :
An immutable class is a class whose objects cannot be changed once they are created.

Why Make a Class Immutable:
Thread safety
Predictable behavior
Easier to debug
Good for keys in hash-based collections (like HashMap)

Steps to Make a Class Immutable:
1.Make the class final
‚Üí So it cannot be extended.

2.Make all fields private and final
‚Üí So values are assigned once and not modified.

3.No setter methods
‚Üí Prevent changing field values after creation.

4.Initialize all fields via constructor

5.If fields are mutable objects (like arrays, lists)
‚Üí Return copies, not references, in getters.

EX CODE:
Step-by-Step Syntax:

// 1. Make the class final
public final class ClassName {

    // 2. Make all fields private and final
    private final DataType fieldName1;
    private final DataType fieldName2;

    // 3. Initialize all fields via constructor
    public ClassName(DataType fieldName1, DataType fieldName2) {
        this.fieldName1 = fieldName1;
        this.fieldName2 = fieldName2;
    }

    // 4. Only provide getter methods (no setters)
    public DataType getFieldName1() {
        return fieldName1;
    }

    public DataType getFieldName2() {
        return fieldName2;
    }

    // 5. If using mutable objects (like arrays/lists), return copies
}

Simple Example: Immutable Person Class:

public final class Person {

    private final String name;
    private final int age;

    // Constructor initializes fields
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Only getters, no setters
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
}

If the class has a mutable field (like List):

public final class Student {

    private final String name;
    private final List<String> subjects;

    public Student(String name, List<String> subjects) {
        this.name = name;
        this.subjects = new ArrayList<>(subjects);  // Defensive copy
    }

    public String getName() {
        return name;
    }

    public List<String> getSubjects() {
        return new ArrayList<>(subjects);  // Return copy, not original
    }
}

| Term       | Meaning                          |
| ---------- | -------------------------------- |
| **Class**  | Blueprint (definition)           |
| **Object** | Real thing (created using class) |
| **Field**  | Variable inside a class          |
| **Method** | Function inside a class          |

Key Rules :

| Rule                            | Syntax                               |
| ------------------------------- | ------------------------------------ |
| Make class immutable            | `public final class MyClass { ... }` |
| Make fields final               | `private final String name;`         |
| No setters                      | ‚ùå Don't use `setName()`              |
| Provide constructor             | `public MyClass(...) { ... }`        |
| Return copies for mutable types | `return new ArrayList<>(list);`      |


=================================================================================
OBJECT:
an object is a real-world entity created from a class.

* A class is a blueprint, and an object is the actual thing made from that blueprint.

5 WAYS:
1.New
2.Class.forName()
3.Clone()
4.ObjectInputStream
5.Factory/Builder

Syntax for Creating an Object:
[ClassName objectName = new ClassName();]


1.Using new keyword :

Student s = new Student();

2.Using Class.forName() (Reflection)

Student s = (Student) Class.forName("Student").newInstance();

newInstance() is deprecated after Java 9 ‚Üí use:

Student s = (Student) Class.forName("Student").getDeclaredConstructor().newInstance()

3.Using clone() Method
Step 1: Implement Cloneable and override clone():

class Student implements Cloneable {
    String name;

    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

Step 2: Use it:

Student s1 = new Student();
s1.name = "Nithya";

Student s2 = (Student) s1.clone();  // Cloned object

4.Using ObjectInputStream (Deserialization)
Step 1: Class must implement Serializable:

class Student implements Serializable {
    String name;
    int age;
}

Step 2: Read from a file:

ObjectInputStream in = new ObjectInputStream(new FileInputStream("student.ser"));
Student s = (Student) in.readObject();

5.Factory Method / Builder Pattern:
class StudentFactory {
    public static Student createStudent() {
        return new Student();
    }
}

// Usage:
Student s = StudentFactory.createStudent();

5 Ways to Create an Object in Java:

| Method                              | Description                              |
| ----------------------------------- | ---------------------------------------- |
| 1. `new` keyword                    | Most common way                          |
| 2. `Class.forName()`                | Reflection                               |
| 3. `clone()`                        | Copy of an existing object               |
| 4. `ObjectInputStream`              | Deserialize object from a file           |
| 5. Factory Method / Builder Pattern | Design pattern to create complex objects |

EX CODE :
public class Main {
    public static void main(String[] args) {
        Student s1 = new Student(); // üî∏ Object created
        s1.name = "Nithya";         // üî∏ Accessing fields
        s1.age = 21;

        s1.display();               // üî∏ Calling method using object
    }
}

===========================================================================
Method:
A method in Java is a block of code that performs a specific task.

Syntax of a Method:

returnType methodName(parameters) {
    // method body
}

Example:
public class Example {

    // Method with no parameters and no return type
    void sayHello() {
        System.out.println("Hello, Java!");
    }

    // Method with parameters and return value
    int add(int a, int b) {
        return a + b;
    }

    public static void main(String[] args) {
        Example obj = new Example();

        obj.sayHello(); // Calling method
        int result = obj.add(10, 20); // Method with return
        System.out.println("Sum: " + result);
    }
}

Types of Methods:
| Type                     | Description                                            |
| ------------------------ | ------------------------------------------------------ |
| **Predefined Methods**   | Already provided by Java (e.g. `System.out.println()`) |
| **User-defined Methods** | Created by the programmer                              |
| **Static Methods**       | Belong to the class (not object), use `static` keyword |
| **Instance Methods**     | Belong to an object                                    |
| **Abstract Methods**     | Declared in abstract class/interface, no body          |

Key Parts of a Method:
| Part         | Meaning                                       |
| ------------ | --------------------------------------------- |
| `returnType` | What the method returns (`int`, `void`, etc.) |
| `methodName` | Name of the method                            |
| `parameters` | Input values                                  |
| `body`       | Code block (what it does)                     |


Why Use Methods?
Reusability
Code organization
Reduces duplication
Easier debugging and maintenance



===========================================================================
Variables:
A variable in Java is a named container that stores data during program execution.
----->container that stores data.

Name (identifier)
Type (data type)
Value (data stored)

Syntax:
[dataType variableName = value;]

TYPES IN VARIABLES:*local
                   *Instance
                   *Static

1.Local Variable:[Temporary use inside a method]
A local variable is created and used only inside a method or block. It exists temporarily while the method runs.

Example:
public class Example {
    public void show() {
        int temp = 5;  // local variable
        System.out.println(temp);
    }
}

2.Instance Variable:[Belongs to the object]
An instance variable is declared inside a class, but outside any method.
Each object (instance) of the class gets its own copy.

EXAMPLE:
public class Student {
    String name;  // instance variable

    public void printName() {
        System.out.println(name);
    }
}
3.Static Variable:[Shared by all objects]
A static variable is also declared in a class, but with the static keyword.
It is shared by all objects of the class.

EXAMPLE:

public class Student {
    static String school = "ABC High School";  // static variable
}


| Type                  | Description                               | Example                      |
| --------------------- | ----------------------------------------- | ---------------------------- |
| **Local Variable**    | Declared inside methods                   | `int x = 5;` inside `main()` |
| **Instance Variable** | Declared inside a class (not static)      | `String name;`               |
| **Static Variable**   | Declared with `static` keyword in a class | `static int count = 0;`      |

EX CODE:

public class Student {
    
    // Instance variable
    String name;
    
    // Static variable
    static String college = "ABC College";
    
    public void displayDetails() {
        // Local variable
        int rollNo = 101;
        System.out.println("Name: " + name);
        System.out.println("Roll No: " + rollNo);
        System.out.println("College: " + college);
    }

    public static void main(String[] args) {
        Student s1 = new Student();
        s1.name = "Nithya";
        s1.displayDetails();
    }
}

=====================================================================
DATA TYPES:
Data types in Java specify what kind of data a variable can store.

Syntax:
[data_type variable_name = value;]

TYPES:
1.Primitive
2.Non-Primitive


1. Primitive Data Types (8 types):

Primitive data types are the basic built-in data types in Java.
They are not objects, and they store actual values directly in memory.


| Type      | Size    | Stores                          | Example             |
| --------- | ------- | ------------------------------- | ------------------- |
| `byte`    | 1 byte  | Small integer (-128 to 127)     | `byte a = 10;`      |
| `short`   | 2 bytes | Small integer                   | `short s = 500;`    |
| `int`     | 4 bytes | Integer                         | `int x = 1000;`     |
| `long`    | 8 bytes | Large integer                   | `long l = 123456L;` |
| `float`   | 4 bytes | Decimal number (low precision)  | `float f = 5.5f;`   |
| `double`  | 8 bytes | Decimal number (high precision) | `double d = 99.99;` |
| `char`    | 2 bytes | Single character                | `char c = 'A';`     |
| `boolean` | 1 bit   | true or false                   | `boolean b = true;` |


EX CODE:
public class PrimitiveExample {
    public static void main(String[] args) {
        int age = 25;
        char grade = 'A';
        boolean isPassed = true;
        float height = 5.7f;

        System.out.println("Age: " + age);
        System.out.println("Grade: " + grade);
        System.out.println("Passed: " + isPassed);
        System.out.println("Height: " + height);
    }
}

2. Non-Primitive Data:

Data types that are created using classes or interfaces, and store references (addresses) to memory locations, not actual values directly.

EX CODE:

public class Example {
    public static void main(String[] args) {
        // String (non-primitive)
        String name = "Java";

        // Array (non-primitive)
        int[] numbers = {10, 20, 30};

        // Object of custom class
        Student s = new Student("Nithya", 21);

        System.out.println("Name: " + name);
        System.out.println("First Number: " + numbers[0]);
        s.showInfo();
    }
}

class Student {
    String name;
    int age;

    Student(String n, int a) {
        name = n;
        age = a;
    }

    void showInfo() {
        System.out.println("Student Name: " + name);
        System.out.println("Age: " + age);
    }
}

| Type     | Description                          | Example                      |
| -------- | ------------------------------------ | ---------------------------- |
| `String` | Stores sequence of characters (text) | `String s = "Hello";`        |
| `Array`  | Stores multiple values of same type  | `int[] arr = {1,2,3};`       |
| `Class`  | Blueprint for creating objects       | `Student s = new Student();` |
| `Object` | Instance of a class                  | Same as above                |


Key Difference from Primitive:
üîπ Primitive: Stores actual value

üîπ Non-Primitive: Stores reference to the value (object)



================================================================================
String:
a String is a non-primitive data type that is used to store a sequence of characters (text).

-->a String is used to store text (a sequence of characters).

Syntax:
[String variableName = "value";]

Ex code:
public class StringSyntaxExample {
    public static void main(String[] args) {
        String message = "Hello Java";

        System.out.println("Message: " + message);
        System.out.println("Length: " + message.length());
        System.out.println("First Letter: " + message.charAt(0));
        System.out.println("Uppercase: " + message.toUpperCase());
    }
}

EX CODE:
public class StringSyntaxExample {
    public static void main(String[] args) {
        String message = "Hello Java";

        System.out.println("Message: " + message);
        System.out.println("Length: " + message.length());
        System.out.println("First Letter: " + message.charAt(0));
        System.out.println("Uppercase: " + message.toUpperCase());
    }
}


1. String Literal:
A hardcoded string written inside double quotes.
---------->
SCP (String Constant Pool)
Meaning: A special memory area inside the JVM to store string literals.

2. String Object:
A string created using the new keyword.

----------->
Heap Memory
Meaning: The main memory where all Java objects are stored.

3. StringBuffer:
A mutable (changeable) version of a string that is thread-safe (synchronized).
--------->
Synchronized:
Meaning: Only one thread can access a block/method at a time.
Used for: Thread safety in multi-threaded programs.

4. StringBuilder:
A mutable version like StringBuffer but not synchronized.
----------->
Asynchronized (or Unsynchronized)
Meaning: Multiple threads can access the method at the same time.
Used for: Faster performance in single-threaded applications.




| Type           | Stored In | Mutable | Synchronized | Thread-Safe | Best Use Case                      |
| -------------- | --------- | ------- | ------------ | ----------- | ---------------------------------- |
| String Literal | SCP       | ‚ùå No    | ‚ùå No         | ‚úÖ Yes       | Constant text reuse                |
| String Object  | Heap      | ‚ùå No    | ‚ùå No         | ‚úÖ Yes       | Always create new string instance  |
| StringBuffer   | Heap      | ‚úÖ Yes   | ‚úÖ Yes        | ‚úÖ Yes       | Multi-thread string modifications  |
| StringBuilder  | Heap      | ‚úÖ Yes   | ‚ùå No         | ‚ùå No        | Fast string edits in single-thread |


| Term          | What is it?                   | Used For                      | Thread-Safe | Speed          |
| ------------- | ----------------------------- | ----------------------------- | ----------- | -------------- |
| Synchronized  | One thread at a time (locked) | Safe multi-threading          | ‚úÖ Yes       | üê¢ Slow        |
| Asynchronized | Multiple threads at once      | Fast, but not safe in threads | ‚ùå No        | ‚ö° Fast         |
| SCP           | String Constant Pool (in JVM) | Reusing string literals       | ‚úÖ Yes       | Very efficient |
| Heap          | Main object memory (in JVM)   | Storing all objects           | ‚úÖ/‚ùå         | Normal         |


EX CODE :
public class StringExample {

    public static void main(String[] args) {

        // 1. String Literal (Stored in SCP)
        String str1 = "Java";
        String str2 = "Java";
        System.out.println("String Literal:");
        System.out.println("str1 == str2: " + (str1 == str2));  // true, both in SCP
        System.out.println("str1.equals(str2): " + str1.equals(str2));  // true

        // 2. String Object (Stored in Heap)
        String str3 = new String("Java");
        String str4 = new String("Java");
        System.out.println("\nString Object:");
        System.out.println("str3 == str4: " + (str3 == str4));  // false, different heap objects
        System.out.println("str3.equals(str4): " + str3.equals(str4));  // true

        // 3. StringBuffer (Mutable and Synchronized)
        StringBuffer buffer = new StringBuffer("Hello");
        buffer.append(" World");
        System.out.println("\nStringBuffer (Synchronized): " + buffer);  // Hello World

        // 4. StringBuilder (Mutable and Not Synchronized)
        StringBuilder builder = new StringBuilder("Hi");
        builder.append(" Java");
        System.out.println("StringBuilder (Not Synchronized): " + builder);  // Hi Java
    }
}


====================================================================================

Constructors :
A constructor in Java is a special method used to initialize objects when they are created.


SYNTAX:
class ClassName {
    // Constructor declaration
    ClassName() {
        // constructor body
        // initialization code
    }
}


Types of Constructors:
1.Default Constructor.
2.Parameterized Constructor
3.Copy Constructor


1.Default Constructor:
A constructor that has no parameters.
It is used to create an object with default values.

CODE:
class Car {
    Car() {  // default constructor
        System.out.println("Default constructor called");
    }
}

2. Parameterized Constructor:
A constructor that takes arguments (parameters) to initialize an object with custom values.


CODE:
class Car {
    String model;
    
    Car(String name) {  // parameterized constructor
        model = name;
    }
}

3. Copy Constructor
A constructor that creates a new object by copying another object of the same class.

CODE:
class Car {
    String model;

    Car(Car c) {  // copy constructor
        this.model = c.model;
    }
}


| Type                          | Description                                     |
| ----------------------------- | ----------------------------------------------- |
| **Default Constructor**       | No parameters, created by Java if none provided |
| **Parameterized Constructor** | Accepts arguments to initialize fields          |
| **Copy Constructor**          | Creates an object by copying another object     |

================================================================================

OOPS:
OOPS stands for Object-Oriented Programming System.
Java is based on the OOPS concept, which focuses on using objects and classes to design programs.


TYPES:
1.Encapsulation	
2.Inheritance	
3.Polymorphism
4.Abstraction


1. Encapsulation:
Encapsulation is the process of wrapping data (variables) and code (methods) together as a single unit.
It hides internal details from the outside world.
Achieved using private variables and public getter/setter methods.

CODE:

class Student {
    private int age; // private variable (data hiding)

    public void setAge(int a) { // public setter
        age = a;
    }

    public int getAge() { // public getter
        return age;
    }
}

2. Inheritance:
Inheritance means one class can acquire the properties and behaviors (methods/fields) of another class.
Used for code reusability.
Java uses extends keyword.

CODE:
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("Dog barks");
    }
}

3. Polymorphism ‚Äì Meaning
Polymorphism means one thing behaves in many forms.

Compile-time polymorphism ‚Üí 
Method overloading (same method name, different parameters).

Runtime polymorphism ‚Üí 
Method overriding (child class changes parent method behavior).

CODE:
// Method Overloading
class Math {
    int add(int a, int b) {
        return a + b;
    }

    double add(double a, double b) {
        return a + b;
    }
}
// Method Overriding
class Animal {
    void sound() {
        System.out.println("Animal sound");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("Meow");
    }
}


4. Abstraction:
Abstraction means hiding the internal implementation and showing only the functionality.
Achieved using abstract classes and interfaces.
Helps to focus on what the object does instead of how it does it.

CODE:

abstract class Shape {
    abstract void draw(); // abstract method
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing Circle");
    }
}


Encapsulation ‚Äì Bind data & methods, hide data using access modifiers.

Inheritance ‚Äì Reuse code from parent class using extends.

Polymorphism ‚Äì Same method name with different behavior.

Abstraction ‚Äì Hide internal details using abstract classes or interface.


| Concept              | Meaning                                                                                |
| -------------------- | -------------------------------------------------------------------------------------- |
| 1. **Encapsulation** | Hiding internal data using private variables and accessing them via methods            |
| 2. **Inheritance**   | One class (child) can inherit properties and behavior from another (parent)            |
| 3. **Polymorphism**  | One action behaves differently in different situations (method overloading/overriding) |
| 4. **Abstraction**   | Hiding implementation details and showing only necessary features                      |

====================================================================================
SCANNER CLASS:
Scanner is a class in Java used to take input from the user, file, or string.

Scanner Means:
A tool/helper that reads input like:
Text (words, lines)
Numbers (int, double, etc.)
Booleans (true/false)


CODE:
import java.util.Scanner;

public class InputExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in); // create scanner

        System.out.print("Enter name: ");
        String name = sc.nextLine();         // read a line

        System.out.print("Enter age: ");
        int age = sc.nextInt();              // read an int

        System.out.println("Name: " + name);
        System.out.println("Age: " + age);

        sc.close(); // close scanner
    }
}

===================================================================================

Operators:
Operators in Java are symbols that perform operations on variables and values.

TYPES:
1.Arithmetic
2.Relational / Comparison
3.Logical
4.Assignment
5.Unary
6.Bitwise
7.Ternary

Arithmetic Operators:
Arithmetic means basic mathematical operations.
In Java, arithmetic operators are used to perform math on numbers (like addition, subtraction, etc.).

List of Arithmetic Operators:

| Operator | Meaning             | Example (a = 10, b = 5) | Result |
| -------- | ------------------- | ----------------------- | ------ |
| `+`      | Addition            | `a + b`                 | 15     |
| `-`      | Subtraction         | `a - b`                 | 5      |
| `*`      | Multiplication      | `a * b`                 | 50     |
| `/`      | Division            | `a / b`                 | 2      |
| `%`      | Modulus (Remainder) | `a % b`                 | 0      |

CODE:
public class ArithmeticExample {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;

        System.out.println("Addition: " + (a + b));       // 15
        System.out.println("Subtraction: " + (a - b));    // 5
        System.out.println("Multiplication: " + (a * b)); // 50
        System.out.println("Division: " + (a / b));       // 2
        System.out.println("Modulus: " + (a % b));        // 0
    }
}

Relational / Comparison Operators :
Relational (Comparison) Operators are used to compare two values.
The result is always a boolean: true or false.

List of Relational Operators:

| Operator | Meaning                  | Example (a = 10, b = 5) | Result |
| -------- | ------------------------ | ----------------------- | ------ |
| `==`     | Equal to                 | `a == b`                | false  |
| `!=`     | Not equal to             | `a != b`                | true   |
| `>`      | Greater than             | `a > b`                 | true   |
| `<`      | Less than                | `a < b`                 | false  |
| `>=`     | Greater than or equal to | `a >= b`                | true   |
| `<=`     | Less than or equal to    | `a <= b`                | false  |

CODE:

public class RelationalExample {
    public static void main(String[] args) {
        int a = 10;
        int b = 5;

        System.out.println("a == b : " + (a == b));  // false
        System.out.println("a != b : " + (a != b));  // true
        System.out.println("a > b  : " + (a > b));   // true
        System.out.println("a < b  : " + (a < b));   // false
        System.out.println("a >= b : " + (a >= b));  // true
        System.out.println("a <= b : " + (a <= b));  // false
    }
}

Logical Operators :
Logical Operators are used to combine two or more conditions (true/false values).
They are mostly used in if, while, or decision-making statements.

List of Logical Operators:

| Operator | Name | Meaning                                            | Example (a=10, b=5)         |                                            |           |   |                  |
| -------- | ---- | -------------------------------------------------- | --------------------------- | ------------------------------------------ | --------- | - | ---------------- |
| `&&`     | AND  | True if **both** conditions are true               | `(a > b) && (a > 0)` ‚Üí true |                                            |           |   |                  |
| \`       |      | \`                                                 | OR                          | True if **at least one** condition is true | \`(a > b) |   | (b < 0)\` ‚Üí true |
| `!`      | NOT  | Reverses the condition: true ‚Üí false, false ‚Üí true | `!(a > b)` ‚Üí false          |                                            |           |   |                  |

CODE:
public class LogicalExample {
    public static void main(String[] args) {
        int a = 10, b = 5;

        // AND: both must be true
        System.out.println("(a > b) && (a > 0): " + ((a > b) && (a > 0))); // true

        // OR: at least one must be true
        System.out.println("(a < b) || (b > 0): " + ((a < b) || (b > 0))); // true

        // NOT: reverses result
        System.out.println("!(a == b): " + !(a == b)); // true
    }
}


Assignment Operators:
Assignment operators are used to assign values to variables.

Basic Assignment Operator:

| Operator | Meaning      | Example  | Explanation       |
| -------- | ------------ | -------- | ----------------- |
| `=`      | Assign value | `a = 10` | Assigns 10 to `a` |

Compound Assignment Operators:
| Operator | Meaning             | Example  | Same as     |
| -------- | ------------------- | -------- | ----------- |
| `+=`     | Add and assign      | `a += 5` | `a = a + 5` |
| `-=`     | Subtract and assign | `a -= 3` | `a = a - 3` |
| `*=`     | Multiply and assign | `a *= 2` | `a = a * 2` |
| `/=`     | Divide and assign   | `a /= 4` | `a = a / 4` |
| `%=`     | Modulus and assign  | `a %= 2` | `a = a % 2` |

CODE:

public class AssignmentOperatorsExample {
    public static void main(String[] args) {
        int a = 10;  // Simple assignment
        System.out.println("Initial value of a: " + a);

        a += 5;  // a = a + 5
        System.out.println("After a += 5: " + a);  // 15

        a -= 3;  // a = a - 3
        System.out.println("After a -= 3: " + a);  // 12

        a *= 2;  // a = a * 2
        System.out.println("After a *= 2: " + a);  // 24

        a /= 4;  // a = a / 4
        System.out.println("After a /= 4: " + a);  // 6

        a %= 4;  // a = a % 4
        System.out.println("After a %= 4: " + a);  // 2
    }
}

Unary Operators:
Unary operators work on only one operand (one variable).
They are used to increment, decrement, or reverse the value.

Types of Unary Operators:
| Operator | Name        | Meaning                    | Example (`int a = 5`) |
| -------- | ----------- | -------------------------- | --------------------- |
| `+`      | Unary plus  | Indicates a positive value | `+a` = 5              |
| `-`      | Unary minus | Negates the value          | `-a` = -5             |
| `++`     | Increment   | Increases value by 1       | `++a` or `a++`        |
| `--`     | Decrement   | Decreases value by 1       | `--a` or `a--`        |
| `!`      | Logical NOT | Reverses boolean value     | `!true` = false       |

Postfix vs Prefix:

| Type    | Syntax | Meaning                               |
| ------- | ------ | ------------------------------------- |
| Prefix  | `++a`  | Increments first, then uses the value |
| Postfix | `a++`  | Uses the value first, then increments |

CODE:
public class UnaryOperatorsExample {
    public static void main(String[] args) {
        int a = 5;
        boolean b = true;

        System.out.println("Original a: " + a);

        System.out.println("Unary plus (+a): " + (+a));  // 5
        System.out.println("Unary minus (-a): " + (-a)); // -5

        System.out.println("Post-increment (a++): " + (a++)); // 5 (then a becomes 6)
        System.out.println("After post-increment, a: " + a);  // 6

        System.out.println("Pre-increment (++a): " + (++a));  // 7

        System.out.println("Post-decrement (a--): " + (a--)); // 7 (then a becomes 6)
        System.out.println("After post-decrement, a: " + a);  // 6

        System.out.println("Pre-decrement (--a): " + (--a));  // 5

        System.out.println("Logical NOT (!b): " + (!b));      // false
    }
}

Bitwise Operators :
Bitwise operators work on the binary (bit) level of integers (int, long, etc.).
They are used to manipulate individual bits of a number.

List of Bitwise Operators:

| Operator | Name                 | Meaning                            | Example (`a = 5`, `b = 3`)           |     |                |
| -------- | -------------------- | ---------------------------------- | ------------------------------------ | --- | -------------- |
| `&`      | AND                  | 1 if both bits are 1               | `5 & 3` ‚Üí `0101 & 0011` = `0001` = 1 |     |                |
| \`       | \`                   | OR                                 | 1 if any one of the bits is 1        | \`5 | 3`=`0111\` = 7 |
| `^`      | XOR                  | 1 if bits are different            | `5 ^ 3` = `0110` = 6                 |     |                |
| `~`      | NOT (1‚Äôs complement) | Flip all bits                      | `~5` ‚Üí flips 0101 to 1010...         |     |                |
| `<<`     | Left shift           | Shifts bits left (multiplies by 2) | `5 << 1` = 10                        |     |                |
| `>>`     | Right shift          | Shifts bits right (divides by 2)   | `5 >> 1` = 2                         |     |                |

CODE:
public class BitwiseOperatorsExample {
    public static void main(String[] args) {
        int a = 5;  // Binary: 0101
        int b = 3;  // Binary: 0011

        System.out.println("a & b (AND): " + (a & b));   // 1
        System.out.println("a | b (OR): " + (a | b));    // 7
        System.out.println("a ^ b (XOR): " + (a ^ b));   // 6
        System.out.println("~a (NOT): " + (~a));         // -6 (in 2's complement)
        System.out.println("a << 1 (Left shift): " + (a << 1)); // 10
        System.out.println("a >> 1 (Right shift): " + (a >> 1)); // 2
    }
}

Ternary Operator:
The Ternary Operator is a shortcut for if-else condition.
It evaluates a condition and returns one of two values based on whether the condition is true or false.

CODE:
public class TernaryExample {
    public static void main(String[] args) {
        int number = 10;

        // Check if number is even or odd
        String type = (number % 2 == 0) ? "Even" : "Odd";

        System.out.println("Number is " + type);
    }
}


| Type of Operator               | Description                  | Example                          |                           |         |
| ------------------------------ | ---------------------------- | -------------------------------- | ------------------------- | ------- |
| **1. Arithmetic**              | Basic math operations        | `+`, `-`, `*`, `/`, `%`          |                           |         |
| **2. Relational / Comparison** | Compare two values           | `==`, `!=`, `>`, `<`, `>=`, `<=` |                           |         |
| **3. Logical**                 | Combine boolean expressions  | `&&`, \`                         |                           | `, `!\` |
| **4. Assignment**              | Assign values to variables   | `=`, `+=`, `-=`, etc.            |                           |         |
| **5. Unary**                   | Works with a single operand  | `+`, `-`, `++`, `--`, `!`        |                           |         |
| **6. Bitwise**                 | Works on bits (advanced use) | `&`, \`                          | `, `^`, `\~`, `<<`, `>>\` |         |
| **7. Ternary**                 | Short if-else condition      | `condition ? a : b`              |                           |         |
| **8. instanceof**              | Checks object type           | `obj instanceof ClassName`       |                           |         |

==============================================================================================

ACCESS MODIFIERS:
Access Modifiers in Java control which parts of a program can access classes, methods, and variables.
They help in encapsulation, security, and code structure.

Types of Access Modifiers:
1.PUBLIC
2.PRIVATE
3.PROTRCTED
4.DEFAULT

1. public ‚Äî Open to All
Can be accessed from anywhere ‚Äî from any class, file, or package.

Use:
When you want your method, variable, or class to be available everywhere.

Example:
public class Example {
    public int num = 10;

    public void show() {
        System.out.println("Public Method");
    }
}

2. private ‚Äî Only Inside the Class
Can be accessed only within the same class.
Not accessible from other classes ‚Äî even in the same file.

Use:
To hide data. Useful in encapsulation (data hiding).

Example:
public class Example {
    private int num = 20;

    private void show() {
        System.out.println("Private Method");
    }
}

3. protected ‚Äî Package + Subclass Access
Accessible:
Inside the same package
In subclasses (child classes) from other packages

Use:
When you want to allow access only for child classes and classes in the same package.

Example:
public class Example {
    protected int num = 30;

    protected void show() {
        System.out.println("Protected Method");
    }
}

4. default (no keyword) ‚Äî Package Only
If you don't write any modifier, it's default access.
Can be accessed only within the same package.

Use:
When you want to restrict access to the current package only.

EXAMPLE:
class Example {  // default class (no modifier)
    int num = 40;

    void show() {
        System.out.println("Default Method");
    }
}

| Modifier                   | Where it can be accessed from                      | Keyword     | Use for              |
| -------------------------- | -------------------------------------------------- | ----------- | -------------------- |
| **public**                 | Anywhere in any class or package                   | `public`    | Open access          |
| **private**                | Only within the same class                         | `private`   | Restrict access      |
| **protected**              | Within same package + subclasses in other packages | `protected` | Inheritance          |
| **default** *(no keyword)* | Only within the same package (not outside)         | *(none)*    | Package-level access |


| Modifier    | Same Class | Same Package | Subclass (other package) | Other Package |
| ----------- | ---------- | ------------ | ------------------------ | ------------- |
| `public`    | ‚úÖ          | ‚úÖ            | ‚úÖ                        | ‚úÖ             |
| `private`   | ‚úÖ          | ‚ùå            | ‚ùå                        | ‚ùå             |
| `protected` | ‚úÖ          | ‚úÖ            | ‚úÖ                        | ‚ùå             |
| `default`   | ‚úÖ          | ‚úÖ            | ‚ùå                        | ‚ùå             |
==================================================================================

ARRAYS:

An array in Java is a container object that holds multiple values of the same data type in a single variable.

It stores data in a fixed size.
It allows access by index (starting from 0).
Data type must be the same (e.g., all int, all String, etc.).

Types of Arrays
1.One-Dimensional Array ‚Üí Like a list
2.Two-Dimensional Array ‚Üí Like a table (matrix)

1. One-Dimensional Array in Java
A One-Dimensional Array stores a list of values of the same data type in a single row.
Think of it like a row of boxes:
[10, 20, 30, 40, 50]


SYNTAX:
// Declaration
int[] arr;

// Creation
arr = new int[5];  // creates an array of size 5 (index 0 to 4)

// Initialization
arr[0] = 10;
arr[1] = 20;
// ... up to arr[4]

// Declaration + Creation + Initialization in one line
int[] arr = {10, 20, 30, 40, 50};

CODE:
public class OneDArrayExample {
    public static void main(String[] args) {
        int[] arr = {5, 10, 15, 20};

        for (int i = 0; i < arr.length; i++) {
            System.out.println("Element at index " + i + ": " + arr[i]);
        }
    }
}


2. Two-Dimensional Array in Java
A Two-Dimensional Array stores values in rows and columns ‚Äî like a table or matrix.
Think of it like:
[ [1, 2],  
  [3, 4] ]

SYNTAX:
// Declaration
int[][] matrix;

// Creation
matrix = new int[2][3]; // 2 rows, 3 columns

// Initialization
matrix[0][0] = 1;
matrix[0][1] = 2;
matrix[1][2] = 6;

// Declaration + Initialization
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6}
};

CODE:
public class TwoDArrayExample {
    public static void main(String[] args) {
        int[][] matrix = {
            {1, 2},
            {3, 4}
        };

        for (int i = 0; i < 2; i++) {            // rows
            for (int j = 0; j < 2; j++) {        // columns
                System.out.print(matrix[i][j] + " ");
            }
            System.out.println();
        }
    }
}


===============================================================================

ABSTRACT METHOD:
An abstract method is a method without a body ‚Äî it only has the name and signature, but no code inside.

You declare it using the keyword abstract.
------>An abstract method is a method that:
Has no body (no code inside)
Is declared using the abstract keyword
Must be overridden in a subclass
It belongs inside an abstract class or interface.

Simple Meaning:
"Abstract method means ‚Äî it‚Äôs just an idea or rule.
The real work (code) will be written in another class (child class)."


SYNTAX:
abstract return_type methodName();

EXAMPLE:
Abstract Class:
abstract class Animal {
    // Abstract method (no body)
    abstract void sound();

    // Concrete method (has body)
    void sleep() {
        System.out.println("Sleeping...");
    }
}

// Subclass must override abstract method
class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}
------
Main Class:
public class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.sound();   // Output: Dog barks
        d.sleep();   // Output: Sleeping...
    }
}

ANOTHER CODE:
abstract class Animal {
    abstract void sound();  // No body ‚Üí child must define it
}
CHILD CLASS:
class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

| Term              | Meaning                               |
| ----------------- | ------------------------------------- |
| `abstract method` | Method with no body                   |
| Purpose           | Must be overridden by child class     |
| Declared in       | Abstract class or interface           |
| Can't do          | You can't write the actual code in it |

================================================================================
EXCEPTION :

An exception in Java is an error or problem that happens during program execution (runtime) that interrupts normal flow of the program.

Simple Meaning:
An exception is like a warning or error that tells Java.

Exception Handling:

Exception handling in Java is a way to catch and manage errors that happen at runtime, so that your program does not crash.


Basic Rules:
try must be followed by catch or finally
You can have multiple catch blocks
Use finally to close files, database, etc.

Why Exception Handling?
To handle runtime errors (like divide by zero)
To avoid program crash
To show meaningful messages.

SYNTAX:
try {
    // Code that may cause exception
} catch (ExceptionType e) {
    // Code to handle the exception
} finally {
    // Code that always runs (optional)
}

try-Block
It is used to write code that may cause an error (exception).
SYNTAX:
try {
    // risky code here
}

EX:
try {
    int a = 10 / 0;
}

catch-Block
Used to catch and handle the error from the try block.

SYNTAX:
catch (ExceptionType e) {
    // code to handle the error
}

EX:
catch (ArithmeticException e) {
    System.out.println("Can't divide by zero!");
}

finally-Block:
It runs always, whether an exception is caught or not.
Used for cleanup code like closing files, connections, etc.

SYNTAX:
finally {
    // this code always runs
}

EX:
finally {
    System.out.println("Cleaning up...");
}

throw-Keyword:
Used to manually throw an exception inside a method or block.

SYNTAX:
throw new ExceptionType("error message");

EX:
throw new ArithmeticException("Manual error");

throws-Keyword:
Used in method declaration to say that this method might throw an exception.

SYNTAX:
void methodName() throws ExceptionType {
    // code
}

EX:
public void readFile() throws IOException {
    // reading file code here
}

CODE:
public class Example {
    public static void main(String[] args) {
        try {
            int a = 10;
            int b = 0;
            int result = a / b;  // causes ArithmeticException
            System.out.println("Result: " + result);
        } catch (ArithmeticException e) {
            System.out.println("‚ùó Error: Cannot divide by zero!");
        } finally {
            System.out.println("This always runs (cleanup code).");
        }
    }
}
-----
Full Example:

public class Example {
    public static void main(String[] args) {
        try {
            int result = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Caught an error: " + e.getMessage());
        } finally {
            System.out.println("This will always run.");
        }
    }

    // throws example
    public void checkAge(int age) throws Exception {
        if (age < 18) {
            throw new Exception("Underage");
        }
    }
}


Key Keywords in Java Exception Handling:
| Keyword   | Meaning                                |
| --------- | -------------------------------------- |
| `try`     | Block that may have error code         |
| `catch`   | Handles the error                      |
| `finally` | Always runs, even if error happens     |
| `throw`   | Used to throw an exception manually    |
| `throws`  | Declares exception in method signature |

===================================================================================

Collection Framework:
The Collection Framework in Java is a set of classes and interfaces used to store, manage, and process groups 
of data (objects) in an efficient way.
--->A collection is like a container (like a box or list) that holds multiple elements (objects).
The Collection Framework provides ready-made tools (classes and methods) to:

Add data
Remove data
Sort or search data
Iterate over data

use collections:
| Without Collections | With Collections                 |
| ------------------- | -------------------------------- |
| Use arrays          | Use `ArrayList`, `HashSet`, etc. |
| Fixed size          | Dynamic size                     |
| Limited features    | Many built-in methods            |


Main Interfaces in Collection Framework:

| Interface    | Description                             | Example Class                 |
| ------------ | --------------------------------------- | ----------------------------- |
| `Collection` | Base interface for all collections      |                               |
| `List`       | Ordered collection (duplicates allowed) | `ArrayList`, `LinkedList`     |
| `Set`        | No duplicates                           | `HashSet`, `TreeSet`          |
| `Queue`      | Follows FIFO order                      | `PriorityQueue`, `ArrayDeque` |
| `Map`        | Key-value pairs                         | `HashMap`, `TreeMap`          |



             java.util.Collection (Interface)
                    /     |     \
              List   Set   Queue (Interfaces)
               |      |      |
         ArrayList  HashSet PriorityQueue  (Classes)
         LinkedList TreeSet LinkedList
             |
            Stack

      java.util.Map (Interface)
             |
         HashMap, TreeMap, LinkedHashMap (Classes)

1. Collection Interface:
Root of the hierarchy (excluding Map)
Extended by List, Set, and Queue

2. List Interface:
Ordered, indexed, allows duplicates
| Class        | Description                       |
| ------------ | --------------------------------- |
| `ArrayList`  | Fast, dynamic array               |
| `LinkedList` | Fast insert/delete, doubly linked |
| `Vector`     | Synchronized version of ArrayList |
| `Stack`      | Follows LIFO (Last In First Out)  |

3.Set Interface:
No duplicates, unordered
| Class           | Description               |
| --------------- | ------------------------- |
| `HashSet`       | Fast, no order            |
| `LinkedHashSet` | Maintains insertion order |
| `TreeSet`       | Sorted order (ascending)  |

4.Queue Interface
FIFO (First-In-First-Out) structure
| Class           | Description                 |
| --------------- | --------------------------- |
| `PriorityQueue` | Elements sorted by priority |
| `ArrayDeque`    | Double-ended queue          |
| `LinkedList`    | Can act as a Queue          |

5.Map Interface
Stores key-value pairs
Keys are unique
| Class           | Description                     |
| --------------- | ------------------------------- |
| `HashMap`       | Fast, no order                  |
| `LinkedHashMap` | Maintains insertion order       |
| `TreeMap`       | Sorted by keys (ascending)      |
| `Hashtable`     | Thread-safe map (older version) |

| Type  | Allows Duplicates           | Ordered | Example Classes           |
| ----- | --------------------------- | ------- | ------------------------- |
| List  | ‚úÖ Yes                       | ‚úÖ Yes   | ArrayList, LinkedList     |
| Set   | ‚ùå No                        | ‚ùå No\*  | HashSet, TreeSet          |
| Queue | ‚úÖ Yes                       | ‚úÖ Yes   | LinkedList, PriorityQueue |
| Map   | ‚ùå Keys: No<br>‚úÖ Values: Yes | ‚ùå No\*  | HashMap, TreeMap          |


Interface:(Interface)
This is the main root interface for collections in Java (except Map).
It represents a group of objects known as elements.

It has 3 main sub-interfaces:
1.List
2.Set
3.Queue

1.LIST(interface):
Ordered, allows duplicates
Can access elements by index

Implemented by:
ArrayList ‚Äì Fast random access, dynamic size.
LinkedList ‚Äì Good for insertions/deletions.
Stack ‚Äì LIFO (Last In First Out).

EX:
List<String> names = new ArrayList<>();
names.add("A");
names.add("B");
System.out.println(names); // [A, B]

2.SET (Interface):
No duplicates, unordered (some ordered versions exist)

Implemented by:
HashSet ‚Äì No order, fast operations.
TreeSet ‚Äì Sorted set (ascending order).
LinkedHashSet ‚Äì Maintains insertion order.

EX:
Set<Integer> ids = new HashSet<>();
ids.add(10);
ids.add(20);
ids.add(10); // Ignored
System.out.println(ids); // [10, 20]

3.Queue (Interface):
Follows FIFO (First In First Out) principle

Implemented by:
PriorityQueue ‚Äì Elements sorted by priority.
LinkedList ‚Äì Can work as a queue or list.

EX:
Queue<String> queue = new LinkedList<>();
queue.add("A");
queue.add("B");
queue.remove(); // removes A
System.out.println(queue); // [B]

4.Map (Interface):
Not part of Collection interface but part of the Collection Framework
Stores key-value pairs
Keys must be unique, values can be duplicate
Implemented by:
HashMap ‚Äì Fast, no order
TreeMap ‚Äì Sorted by keys

LinkedHashMap ‚Äì Maintains insertion order
EX:
Map<Integer, String> map = new HashMap<>();
map.put(1, "One");
map.put(2, "Two");
System.out.println(map.get(1)); // One



| Type          | Ordered  | Duplicates  | Key Features              |
| ------------- | -------- | ----------- | ------------------------- |
| List          | Yes      | Yes         | Index-based, ordered      |
| Set           | No\*     | No          | Unique values             |
| Queue         | Yes      | Yes         | FIFO or priority          |
| Map           | Keys: No | Values: Yes | Key-value pairs           |
| ArrayList     | Yes      | Yes         | Fast access               |
| LinkedList    | Yes      | Yes         | Fast insert/delete        |
| Stack         | LIFO     | Yes         | Last in, first out        |
| HashSet       | No       | No          | Fast, unordered set       |
| TreeSet       | Sorted   | No          | Ascending sorted set      |
| PriorityQueue | Sorted   | Yes         | Min-heap by default       |
| HashMap       | No       | Yes         | Unordered key-value pairs |
| TreeMap       | Sorted   | Yes         | Sorted key-value pairs    |
| LinkedHashMap | Yes      | Yes         | Ordered key-value pairs   |
